\chapter{Gramática}

\small
\begin{tabular}{r c p{.72\textwidth}}
	
	programa 		&$\longrightarrow$	& \ter{programa} \ter{id} \\
					&				 	& \sem{ ADD\_INST('prog ' || ID.value); } \\
					&					& declaraciones \\
					&					& decl\_de\_subprogs \\
					&					& \ter{comienzo} \\
					&					& lista\_de\_sentencias\_prima \\
					&					& \ter{fin} \ter{;} \\
					&					& \sem{ ADD\_INST\_inst('halt'); } \\

	\espacio
	
	declaraciones 	&$\longrightarrow$ 	& \ter{variables} lista\_de\_ident \ter{:} tipo \ter{;} \\
					&					& \footnotesize\sem{ if ( IS\_INTEGER( t.tipo) || IS\_REAL(t.tipo) || IS\_BOOLEAN(t.tipo) ) \\
												\{ \\
												\ind FOREACH( lista\_de\_ident.ids AS ident) \\
												\ind\ind ADD\_INST( TYPE\_OF(tipo.tipo) || " " || ident); \\
												\} \\
												else if ( IS\_ARRAY(t.tipo) ) \\
												\ind FOREACH( lista\_de\_ident.ids AS ident) \\
												\ind\ind ADD\_INST( ``array'' || TYPE\_OF(ARRAY\_CONTENT(t.tipo)) || `` '' \\
												\ind\ind\ind\ind\ind\ind\ind\ind || ident || ``,'' || ARRAY\_SIZE(t.tipo) ); \\
										  } \\
					&					& declaraciones \\
										
					& | 					& $\xi$ \\



	\espacio

	declaraciones 	&$\longrightarrow$ 	& \ter{variables} lista\_de\_ident \ter{:} tipo \ter{;} \\
					&					&         \begin{lstlisting}[caption={Trigger para contar lineas en un comentario multilinea}]
void CTokenizer::CheckMultilineComment ( unsigned char c )
{
    static bool bLastCharWasCR = false;

    switch ( c )
    {
        case '\r':
            bLastCharWasCR = true;
            ++m_uiLine;
            m_uiCol = 0;
            break;
        case '\n':
            m_uiCol = 0;
            if ( bLastCharWasCR == true )
            {
                bLastCharWasCR = false;
            }
            else
            {
                ++m_uiLine;
            }
            break;
    }
}
        \end{lstlisting} \\
					&					& declaraciones \\
										
					& | 					& $\xi$ \\

	\espacio
	
	lista\_de\_ident	&$\longrightarrow$	& \ter{id} resto\_lista\_id \\
					&					& \sem{lista\_de\_ident.ids := JOIN( & INIT\_LIST(id.value), \\
																			& resto\_lista\_ident.ids); } \\

\end{tabular}


\small
\begin{tabular}{r c p{.72\textwidth}}
	
	resto\_lista\_ident 	& $\longrightarrow$ 	& \ter{,} \ter{id} resto\_lista\_id \\
						&					& \sem{ resto\_lista\_ident.ids := JOIN(	& INIT\_LIST(id.value) , \\
																					& resto\_lista\_id.ids); } \\
																			
						& | 					& $\xi$ \\
						&					& \sem{ resto\_lista\_ident.ids := EMPTY\_LIST(); } \\

	\espacio
	
	tipo 			& $\longrightarrow$ 	& entero \\
					&					& \sem{ tipo.tipo := 'int'} \\
					
					& | 					& real \\
					&					& \sem{ tipo.tipo := 'real'} \\
					
					& | 					& booleano \\
					&					& \sem{tipo.tipo := 'booleano'} \\

					& | 					& \ter{array} \ter{[} lista\_de\_enteros \ter{]} \ter{de} tipo \\
					&					& \sem{ tipo.tipo := NEW\_ARRAY\_TYPE(lista\_de\_enteros, tipo); } \\
					
	\espacio	
	

	
	lista\_de\_enteros	& $\longrightarrow$ 	& entero resto\_lista\_enteros \\
						&					& \sem{ lista\_de\_enteros := JOIN(INIT\_LIST(entero), resto\_de\_enteros.ints); } \\
					
	\espacio

	resto\_de\_enteros	& $\longrightarrow$ 	& entero resto\_lista\_enteros\textsubscript{1} \\
						&					& \sem{ resto\_de\_enteros := JOIN(	& INIT\_LIST(entero), \\
																				& resto\_de\_enteros\textsubscript{1}.ints); } \\
						& | 					& $\xi$ \\
						&					& \sem{ resto\_de\_enteros := EMPTY\_LIST } \\
					
	\espacio
	
	decl\_de\_subprogs 		& $\longrightarrow$ 	& decl\_de\_procedimiento decl\_de\_subprogs \\
							& |					& decl\_de\_funcion decl\_de\_subprogs \\
							& | 					& $\xi$ \\

\end{tabular}

\small
\begin{tabular}{r c p{.72\textwidth}}

	decl\_de\_procedimiento 	& $\longrightarrow$ 	& \sem{ ST\_PUSH(); } \\
							&					& cabecera\_procedimiento declaraciones \\
							&					& \ter{comienzo} lista\_de\_sentencias\_prima \ter{fin} \\
							&					& \sem{ ADD\_INST(``finproc''); } \\
							&					& \ter{;} \\
							&					& \sem{ ST\_POP(); } \\
							
							
	\espacio
	
	decl\_de\_function	 	& $\longrightarrow$ 	& \sem{ ST\_PUSH(); } \\
							&					& cabecera\_funcion declaraciones \\
							&					& \ter{comienzo} lista\_de\_sentencias\_prima \ter{retornar} expresion \\
							&					& \sem{ if ( & cabecera\_funcion.tipo == expresion.tipo) \{ \\
																& ADD\_INST( ``ret '' || expresion.nombre ); \\
																& ADD\_INST( ``finfunc''); \\
														\} else & \{ \\
																& ERROR( "Function return type mismatch" ); \\
														\} } \\
							&					& \ter{fin} \\
							&					& \ter{;} \\
							&					& \sem{ ST\_POP(); } \\

	\espacio
	
	cabecera	\_procedimiento 	&$\longrightarrow$	& \ter{procedimiento} \ter{id} \\
							& 					& \sem{'proc ' || id.value } \\
							&					& argumentos \\

	\espacio

	cabecera	\_funcion	 	&$\longrightarrow$	& \ter{funcion} \ter{id} \\
							& 					& \sem{'func ' || id.value } \\
							&					& argumentos \ter{retorna} tipo \\
							&					& \sem{cabecera	\_funcion := tipo.tipo } \\
	
	\espacio
		
	argumentos 		&$\longrightarrow$ 	& \ter{(} lista\_de\_param \ter{)} \\
					& | 					& $\xi$ \\
							
\end{tabular}


\small
\begin{tabular}{r c p{.72\textwidth}}
	lista\_de\_param &$\longrightarrow$  	& lista\_de\_ident \ter{:} clase\_par tipo \\
					&					& \sem{ FOREACH(	lista\_de\_ident.ids as id) \{ \\
												\ind ADD\_INST( clase\_par.clase || ``\_'' || TYPE\_OF(tipo.tipo) || `` '' || id); \\
										\} \\
										} \\
					&					& resto\_lis\_de\_param \\
					
	\espacio
	
	resto\_lis\_de\_param 	&$\longrightarrow$ 	& \ter{;} lista\_de\_ident \ter{:} clase\_par tipo \\
							&					& \sem{ FOREACH(	lista\_de\_ident.ids as id) \{ \\
														\ind ADD\_INST(clase\_par.clase || ``\_'' || TYPE\_OF(tipo.tipo) || `` '' || id); \\
												\} } \\
							&					& resto\_lis\_de\_param \\
							& |					& $\xi$ \\

	\espacio


	clase\_par 		& $\longrightarrow$		& entrada clase\_par' \\
					&						& \sem{clase\_par.clase := clase\_par'.clase; } \\ 
					& | 						& salida \\
					&						& \sem{clase\_par := 'ref'; } \\
	
	\espacio
	
	clase\_par' 		& $\longrightarrow$		& salida \\
					&						& \sem{clase\_par := 'ref'; } \\ 
					& | 						& $\xi$ \\
					&						& \sem{clase\_par := 'val'; } \\
					
	\espacio

	lista\_de\_sentencias' 	& $\longrightarrow$ 	& \sem{ lista\_de\_sentencias.hinloop := false; } \\
							& 					& lista\_de\_sentencias \\

	\espacio

\end{tabular}

\small
\begin{tabular}{r c p{.72\textwidth}}
	lista\_de\_sentencias 	& $\longrightarrow$ 	& \sem{sentencia.hinloop:=lista\_de\_sentencias.hinloop} \\
							& 					& sentencia \ter{;} \\
							&					& \sem{ lista\_de\_sentencia\textsubscript{1}.hinloop:=lista\_de\_sentencias.hinloop; } \\
							&					& lista\_de\_sentencias\textsubscript{1} \\
							&					& \sem{ lista\_de\_sentencias.salir\_si := unir( 	& sentencia.salir\_si, \\
																								& lista\_de\_sentencia\textsubscript{1}.salir\_si ) } \\
							& | 					& $\xi$ \\
							&					& \sem{lista\_de\_sentencias.salir\_si := lista\_vacia() } \\

\end{tabular}